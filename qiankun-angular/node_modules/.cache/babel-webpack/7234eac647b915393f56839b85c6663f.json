{"ast":null,"code":"import _classCallCheck from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { startOfWeek, startOfMonth, setYear as _setYear, addYears as _addYears, setMonth as _setMonth, addMonths as _addMonths, setDay as _setDay, isSameDay, isSameSecond, isSameMinute, isSameHour, isSameMonth, isSameYear, differenceInCalendarDays, differenceInSeconds, differenceInMinutes, differenceInHours, differenceInCalendarMonths, differenceInCalendarYears, isToday as _isToday, isValid as _isValid, isFirstDayOfMonth as _isFirstDayOfMonth, isLastDayOfMonth as _isLastDayOfMonth } from 'date-fns';\nimport { warn } from 'ng-zorro-antd/core/logger';\nimport { getLocaleDayPeriods, FormStyle, TranslationWidth } from '@angular/common';\nimport { isNotNil } from 'ng-zorro-antd/core/util';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nfunction wrongSortOrder(rangeValue) {\n  var _rangeValue = _slicedToArray(rangeValue, 2),\n      start = _rangeValue[0],\n      end = _rangeValue[1];\n\n  return !!start && !!end && end.isBeforeDay(start);\n}\n\nfunction normalizeRangeValue(value, hasTimePicker) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'month';\n  var activePart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left';\n\n  var _value = _slicedToArray(value, 2),\n      start = _value[0],\n      end = _value[1];\n\n  var newStart = start || new CandyDate();\n  var newEnd = end || (hasTimePicker ? newStart : newStart.add(1, type));\n\n  if (start && !end) {\n    newStart = start;\n    newEnd = hasTimePicker ? start : start.add(1, type);\n  } else if (!start && end) {\n    newStart = hasTimePicker ? end : end.add(-1, type);\n    newEnd = end;\n  } else if (start && end && !hasTimePicker) {\n    if (start.isSame(end, type)) {\n      newEnd = newStart.add(1, type);\n    } else {\n      if (activePart === 'left') {\n        newEnd = newStart.add(1, type);\n      } else {\n        newStart = newEnd.add(-1, type);\n      }\n    }\n  }\n\n  return [newStart, newEnd];\n}\n\nfunction cloneDate(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return v instanceof CandyDate ? v.clone() : null;\n    });\n  } else {\n    return value instanceof CandyDate ? value.clone() : null;\n  }\n}\n/**\n * Wrapping kind APIs for date operating and unify\n * NOTE: every new API return new CandyDate object without side effects to the former Date object\n * NOTE: most APIs are based on local time other than customized locale id (this needs tobe support in future)\n * TODO: support format() against to angular's core API\n */\n\n\nvar CandyDate = /*#__PURE__*/function () {\n  // locale: string; // Custom specified locale ID\n  function CandyDate(date) {\n    _classCallCheck(this, CandyDate);\n\n    if (date) {\n      if (date instanceof Date) {\n        this.nativeDate = date;\n      } else if (typeof date === 'string' || typeof date === 'number') {\n        warn('The string type is not recommended for date-picker, use \"Date\" type');\n        this.nativeDate = new Date(date);\n      } else {\n        throw new Error('The input date type is not supported (\"Date\" is now recommended)');\n      }\n    } else {\n      this.nativeDate = new Date();\n    }\n  }\n\n  _createClass(CandyDate, [{\n    key: \"calendarStart\",\n    value: function calendarStart(options) {\n      return new CandyDate(startOfWeek(startOfMonth(this.nativeDate), options));\n    } // ---------------------------------------------------------------------\n    // | Native shortcuts\n    // -----------------------------------------------------------------------------\\\n\n  }, {\n    key: \"getYear\",\n    value: function getYear() {\n      return this.nativeDate.getFullYear();\n    }\n  }, {\n    key: \"getMonth\",\n    value: function getMonth() {\n      return this.nativeDate.getMonth();\n    }\n  }, {\n    key: \"getDay\",\n    value: function getDay() {\n      return this.nativeDate.getDay();\n    }\n  }, {\n    key: \"getTime\",\n    value: function getTime() {\n      return this.nativeDate.getTime();\n    }\n  }, {\n    key: \"getDate\",\n    value: function getDate() {\n      return this.nativeDate.getDate();\n    }\n  }, {\n    key: \"getHours\",\n    value: function getHours() {\n      return this.nativeDate.getHours();\n    }\n  }, {\n    key: \"getMinutes\",\n    value: function getMinutes() {\n      return this.nativeDate.getMinutes();\n    }\n  }, {\n    key: \"getSeconds\",\n    value: function getSeconds() {\n      return this.nativeDate.getSeconds();\n    }\n  }, {\n    key: \"getMilliseconds\",\n    value: function getMilliseconds() {\n      return this.nativeDate.getMilliseconds();\n    } // ---------------------------------------------------------------------\n    // | New implementing APIs\n    // ---------------------------------------------------------------------\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CandyDate(new Date(this.nativeDate));\n    }\n  }, {\n    key: \"setHms\",\n    value: function setHms(hour, minute, second) {\n      var newDate = new Date(this.nativeDate.setHours(hour, minute, second));\n      return new CandyDate(newDate);\n    }\n  }, {\n    key: \"setYear\",\n    value: function setYear(year) {\n      return new CandyDate(_setYear(this.nativeDate, year));\n    }\n  }, {\n    key: \"addYears\",\n    value: function addYears(amount) {\n      return new CandyDate(_addYears(this.nativeDate, amount));\n    } // NOTE: month starts from 0\n    // NOTE: Don't use the native API for month manipulation as it not restrict the date when it overflows, eg. (new Date('2018-7-31')).setMonth(1) will be date of 2018-3-03 instead of 2018-2-28\n\n  }, {\n    key: \"setMonth\",\n    value: function setMonth(month) {\n      return new CandyDate(_setMonth(this.nativeDate, month));\n    }\n  }, {\n    key: \"addMonths\",\n    value: function addMonths(amount) {\n      return new CandyDate(_addMonths(this.nativeDate, amount));\n    }\n  }, {\n    key: \"setDay\",\n    value: function setDay(day, options) {\n      return new CandyDate(_setDay(this.nativeDate, day, options));\n    }\n  }, {\n    key: \"setDate\",\n    value: function setDate(amount) {\n      var date = new Date(this.nativeDate);\n      date.setDate(amount);\n      return new CandyDate(date);\n    }\n  }, {\n    key: \"addDays\",\n    value: function addDays(amount) {\n      return this.setDate(this.getDate() + amount);\n    }\n  }, {\n    key: \"add\",\n    value: function add(amount, mode) {\n      switch (mode) {\n        case 'decade':\n          return this.addYears(amount * 10);\n\n        case 'year':\n          return this.addYears(amount);\n\n        case 'month':\n          return this.addMonths(amount);\n\n        default:\n          return this.addMonths(amount);\n      }\n    }\n  }, {\n    key: \"isSame\",\n    value: function isSame(date) {\n      var grain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'day';\n      var fn;\n\n      switch (grain) {\n        case 'decade':\n          fn = function fn(pre, next) {\n            return Math.abs(pre.getFullYear() - next.getFullYear()) < 11;\n          };\n\n          break;\n\n        case 'year':\n          fn = isSameYear;\n          break;\n\n        case 'month':\n          fn = isSameMonth;\n          break;\n\n        case 'day':\n          fn = isSameDay;\n          break;\n\n        case 'hour':\n          fn = isSameHour;\n          break;\n\n        case 'minute':\n          fn = isSameMinute;\n          break;\n\n        case 'second':\n          fn = isSameSecond;\n          break;\n\n        default:\n          fn = isSameDay;\n          break;\n      }\n\n      return fn(this.nativeDate, this.toNativeDate(date));\n    }\n  }, {\n    key: \"isSameYear\",\n    value: function isSameYear(date) {\n      return this.isSame(date, 'year');\n    }\n  }, {\n    key: \"isSameMonth\",\n    value: function isSameMonth(date) {\n      return this.isSame(date, 'month');\n    }\n  }, {\n    key: \"isSameDay\",\n    value: function isSameDay(date) {\n      return this.isSame(date, 'day');\n    }\n  }, {\n    key: \"isSameHour\",\n    value: function isSameHour(date) {\n      return this.isSame(date, 'hour');\n    }\n  }, {\n    key: \"isSameMinute\",\n    value: function isSameMinute(date) {\n      return this.isSame(date, 'minute');\n    }\n  }, {\n    key: \"isSameSecond\",\n    value: function isSameSecond(date) {\n      return this.isSame(date, 'second');\n    }\n  }, {\n    key: \"isBefore\",\n    value: function isBefore(date) {\n      var grain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'day';\n\n      if (date === null) {\n        return false;\n      }\n\n      var fn;\n\n      switch (grain) {\n        case 'year':\n          fn = differenceInCalendarYears;\n          break;\n\n        case 'month':\n          fn = differenceInCalendarMonths;\n          break;\n\n        case 'day':\n          fn = differenceInCalendarDays;\n          break;\n\n        case 'hour':\n          fn = differenceInHours;\n          break;\n\n        case 'minute':\n          fn = differenceInMinutes;\n          break;\n\n        case 'second':\n          fn = differenceInSeconds;\n          break;\n\n        default:\n          fn = differenceInCalendarDays;\n          break;\n      }\n\n      return fn(this.nativeDate, this.toNativeDate(date)) < 0;\n    }\n  }, {\n    key: \"isBeforeYear\",\n    value: function isBeforeYear(date) {\n      return this.isBefore(date, 'year');\n    }\n  }, {\n    key: \"isBeforeMonth\",\n    value: function isBeforeMonth(date) {\n      return this.isBefore(date, 'month');\n    }\n  }, {\n    key: \"isBeforeDay\",\n    value: function isBeforeDay(date) {\n      return this.isBefore(date, 'day');\n    } // Equal to today accurate to \"day\"\n\n  }, {\n    key: \"isToday\",\n    value: function isToday() {\n      return _isToday(this.nativeDate);\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      return _isValid(this.nativeDate);\n    }\n  }, {\n    key: \"isFirstDayOfMonth\",\n    value: function isFirstDayOfMonth() {\n      return _isFirstDayOfMonth(this.nativeDate);\n    }\n  }, {\n    key: \"isLastDayOfMonth\",\n    value: function isLastDayOfMonth() {\n      return _isLastDayOfMonth(this.nativeDate);\n    }\n  }, {\n    key: \"toNativeDate\",\n    value: function toNativeDate(date) {\n      return date instanceof CandyDate ? date.nativeDate : date;\n    }\n  }]);\n\n  return CandyDate;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar timeUnits = [['Y', 1000 * 60 * 60 * 24 * 365], ['M', 1000 * 60 * 60 * 24 * 30], ['D', 1000 * 60 * 60 * 24], ['H', 1000 * 60 * 60], ['m', 1000 * 60], ['s', 1000], ['S', 1] // million seconds\n];\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nvar NgTimeParser = /*#__PURE__*/function () {\n  function NgTimeParser(format, localeId) {\n    _classCallCheck(this, NgTimeParser);\n\n    this.format = format;\n    this.localeId = localeId;\n    this.regex = null;\n    this.matchMap = {\n      hour: null,\n      minute: null,\n      second: null,\n      periodNarrow: null,\n      periodWide: null,\n      periodAbbreviated: null\n    };\n    this.genRegexp();\n  }\n\n  _createClass(NgTimeParser, [{\n    key: \"toDate\",\n    value: function toDate(str) {\n      var result = this.getTimeResult(str);\n      var time = new Date();\n\n      if (isNotNil(result === null || result === void 0 ? void 0 : result.hour)) {\n        time.setHours(result.hour);\n      }\n\n      if (isNotNil(result === null || result === void 0 ? void 0 : result.minute)) {\n        time.setMinutes(result.minute);\n      }\n\n      if (isNotNil(result === null || result === void 0 ? void 0 : result.second)) {\n        time.setSeconds(result.second);\n      }\n\n      if ((result === null || result === void 0 ? void 0 : result.period) === 1 && time.getHours() < 12) {\n        time.setHours(time.getHours() + 12);\n      }\n\n      return time;\n    }\n  }, {\n    key: \"getTimeResult\",\n    value: function getTimeResult(str) {\n      var match = this.regex.exec(str);\n      var period = null;\n\n      if (match) {\n        if (isNotNil(this.matchMap.periodNarrow)) {\n          period = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Narrow).indexOf(match[this.matchMap.periodNarrow + 1]);\n        }\n\n        if (isNotNil(this.matchMap.periodWide)) {\n          period = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Wide).indexOf(match[this.matchMap.periodWide + 1]);\n        }\n\n        if (isNotNil(this.matchMap.periodAbbreviated)) {\n          period = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Abbreviated).indexOf(match[this.matchMap.periodAbbreviated + 1]);\n        }\n\n        return {\n          hour: isNotNil(this.matchMap.hour) ? Number.parseInt(match[this.matchMap.hour + 1], 10) : null,\n          minute: isNotNil(this.matchMap.minute) ? Number.parseInt(match[this.matchMap.minute + 1], 10) : null,\n          second: isNotNil(this.matchMap.second) ? Number.parseInt(match[this.matchMap.second + 1], 10) : null,\n          period: period\n        };\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"genRegexp\",\n    value: function genRegexp() {\n      var _this = this;\n\n      var regexStr = this.format.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$&');\n      var hourRegex = /h{1,2}/i;\n      var minuteRegex = /m{1,2}/;\n      var secondRegex = /s{1,2}/;\n      var periodNarrow = /aaaaa/;\n      var periodWide = /aaaa/;\n      var periodAbbreviated = /a{1,3}/;\n      var hourMatch = hourRegex.exec(this.format);\n      var minuteMatch = minuteRegex.exec(this.format);\n      var secondMatch = secondRegex.exec(this.format);\n      var periodNarrowMatch = periodNarrow.exec(this.format);\n      var periodWideMatch = null;\n      var periodAbbreviatedMatch = null;\n\n      if (!periodNarrowMatch) {\n        periodWideMatch = periodWide.exec(this.format);\n      }\n\n      if (!periodWideMatch && !periodNarrowMatch) {\n        periodAbbreviatedMatch = periodAbbreviated.exec(this.format);\n      }\n\n      var matchs = [hourMatch, minuteMatch, secondMatch, periodNarrowMatch, periodWideMatch, periodAbbreviatedMatch].filter(function (m) {\n        return !!m;\n      }).sort(function (a, b) {\n        return a.index - b.index;\n      });\n      matchs.forEach(function (match, index) {\n        switch (match) {\n          case hourMatch:\n            _this.matchMap.hour = index;\n            regexStr = regexStr.replace(hourRegex, '(\\\\d{1,2})');\n            break;\n\n          case minuteMatch:\n            _this.matchMap.minute = index;\n            regexStr = regexStr.replace(minuteRegex, '(\\\\d{1,2})');\n            break;\n\n          case secondMatch:\n            _this.matchMap.second = index;\n            regexStr = regexStr.replace(secondRegex, '(\\\\d{1,2})');\n            break;\n\n          case periodNarrowMatch:\n            _this.matchMap.periodNarrow = index;\n            var periodsNarrow = getLocaleDayPeriods(_this.localeId, FormStyle.Format, TranslationWidth.Narrow).join('|');\n            regexStr = regexStr.replace(periodNarrow, \"(\".concat(periodsNarrow, \")\"));\n            break;\n\n          case periodWideMatch:\n            _this.matchMap.periodWide = index;\n            var periodsWide = getLocaleDayPeriods(_this.localeId, FormStyle.Format, TranslationWidth.Wide).join('|');\n            regexStr = regexStr.replace(periodWide, \"(\".concat(periodsWide, \")\"));\n            break;\n\n          case periodAbbreviatedMatch:\n            _this.matchMap.periodAbbreviated = index;\n            var periodsAbbreviated = getLocaleDayPeriods(_this.localeId, FormStyle.Format, TranslationWidth.Abbreviated).join('|');\n            regexStr = regexStr.replace(periodAbbreviated, \"(\".concat(periodsAbbreviated, \")\"));\n            break;\n        }\n      });\n      this.regex = new RegExp(regexStr);\n    }\n  }]);\n\n  return NgTimeParser;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CandyDate, cloneDate, normalizeRangeValue, timeUnits, wrongSortOrder, NgTimeParser as ɵNgTimeParser }; //# sourceMappingURL=ng-zorro-antd-core-time.js.map","map":null,"metadata":{},"sourceType":"module"}