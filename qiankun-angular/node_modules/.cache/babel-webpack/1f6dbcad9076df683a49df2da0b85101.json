{"ast":null,"code":"import _createForOfIteratorHelper from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { CommonModule } from '@angular/common';\nimport { TemplateRef, Directive, ViewContainerRef, Input, NgModule } from '@angular/core';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar NzStringTemplateOutletDirective = /*@__PURE__*/function () {\n  var NzStringTemplateOutletDirective = /*#__PURE__*/function () {\n    function NzStringTemplateOutletDirective(viewContainer, templateRef) {\n      _classCallCheck(this, NzStringTemplateOutletDirective);\n\n      this.viewContainer = viewContainer;\n      this.templateRef = templateRef;\n      this.embeddedViewRef = null;\n      this.context = new NzStringTemplateOutletContext();\n      this.nzStringTemplateOutletContext = null;\n      this.nzStringTemplateOutlet = null;\n    }\n\n    _createClass(NzStringTemplateOutletDirective, [{\n      key: \"recreateView\",\n      value: function recreateView() {\n        this.viewContainer.clear();\n        var isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\n        var templateRef = isTemplateRef ? this.nzStringTemplateOutlet : this.templateRef;\n        this.embeddedViewRef = this.viewContainer.createEmbeddedView(templateRef, isTemplateRef ? this.nzStringTemplateOutletContext : this.context);\n      }\n    }, {\n      key: \"updateContext\",\n      value: function updateContext() {\n        var isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\n        var newCtx = isTemplateRef ? this.nzStringTemplateOutletContext : this.context;\n        var oldCtx = this.embeddedViewRef.context;\n\n        if (newCtx) {\n          for (var _i = 0, _Object$keys = Object.keys(newCtx); _i < _Object$keys.length; _i++) {\n            var propName = _Object$keys[_i];\n            oldCtx[propName] = newCtx[propName];\n          }\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var nzStringTemplateOutletContext = changes.nzStringTemplateOutletContext,\n            nzStringTemplateOutlet = changes.nzStringTemplateOutlet;\n\n        var shouldRecreateView = function shouldRecreateView() {\n          var shouldOutletRecreate = false;\n\n          if (nzStringTemplateOutlet) {\n            if (nzStringTemplateOutlet.firstChange) {\n              shouldOutletRecreate = true;\n            } else {\n              var isPreviousOutletTemplate = nzStringTemplateOutlet.previousValue instanceof TemplateRef;\n              var isCurrentOutletTemplate = nzStringTemplateOutlet.currentValue instanceof TemplateRef;\n              shouldOutletRecreate = isPreviousOutletTemplate || isCurrentOutletTemplate;\n            }\n          }\n\n          var hasContextShapeChanged = function hasContextShapeChanged(ctxChange) {\n            var prevCtxKeys = Object.keys(ctxChange.previousValue || {});\n            var currCtxKeys = Object.keys(ctxChange.currentValue || {});\n\n            if (prevCtxKeys.length === currCtxKeys.length) {\n              var _iterator = _createForOfIteratorHelper(currCtxKeys),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var propName = _step.value;\n\n                  if (prevCtxKeys.indexOf(propName) === -1) {\n                    return true;\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              return false;\n            } else {\n              return true;\n            }\n          };\n\n          var shouldContextRecreate = nzStringTemplateOutletContext && hasContextShapeChanged(nzStringTemplateOutletContext);\n          return shouldContextRecreate || shouldOutletRecreate;\n        };\n\n        if (nzStringTemplateOutlet) {\n          this.context.$implicit = nzStringTemplateOutlet.currentValue;\n        }\n\n        var recreateView = shouldRecreateView();\n\n        if (recreateView) {\n          /** recreate view when context shape or outlet change **/\n          this.recreateView();\n        } else {\n          /** update context **/\n          this.updateContext();\n        }\n      }\n    }], [{\n      key: \"ngTemplateContextGuard\",\n      value: function ngTemplateContextGuard(_dir, _ctx) {\n        return true;\n      }\n    }]);\n\n    return NzStringTemplateOutletDirective;\n  }();\n\n  NzStringTemplateOutletDirective.ɵfac = function NzStringTemplateOutletDirective_Factory(t) {\n    return new (t || NzStringTemplateOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  NzStringTemplateOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: NzStringTemplateOutletDirective,\n    selectors: [[\"\", \"nzStringTemplateOutlet\", \"\"]],\n    inputs: {\n      nzStringTemplateOutletContext: \"nzStringTemplateOutletContext\",\n      nzStringTemplateOutlet: \"nzStringTemplateOutlet\"\n    },\n    exportAs: [\"nzStringTemplateOutlet\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return NzStringTemplateOutletDirective;\n}();\n\nvar NzStringTemplateOutletContext = function NzStringTemplateOutletContext() {\n  _classCallCheck(this, NzStringTemplateOutletContext);\n};\n\nvar NzOutletModule = /*@__PURE__*/function () {\n  var NzOutletModule = function NzOutletModule() {\n    _classCallCheck(this, NzOutletModule);\n  };\n\n  NzOutletModule.ɵfac = function NzOutletModule_Factory(t) {\n    return new (t || NzOutletModule)();\n  };\n\n  NzOutletModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: NzOutletModule\n  });\n  NzOutletModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NzOutletModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzOutletModule, {\n    declarations: function declarations() {\n      return [NzStringTemplateOutletDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [NzStringTemplateOutletDirective];\n    }\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzOutletModule, NzStringTemplateOutletDirective }; //# sourceMappingURL=ng-zorro-antd-core-outlet.js.map","map":null,"metadata":{},"sourceType":"module"}