{"ast":null,"code":"import _toConsumableArray from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { __decorate, __metadata } from 'tslib';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Inject, NgZone, Renderer2, ChangeDetectorRef, Optional, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { NzConfigService, WithConfig } from 'ng-zorro-antd/core/config';\nimport { NzScrollService } from 'ng-zorro-antd/core/services';\nimport { shallowEqual, getStyleAsText, InputNumber } from 'ng-zorro-antd/core/util';\nimport { Subscription, ReplaySubject, Subject, merge, fromEvent } from 'rxjs';\nimport { takeUntil, map, auditTime } from 'rxjs/operators';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ng-zorro-antd/core/config';\nimport * as ɵngcc2 from 'ng-zorro-antd/core/services';\nimport * as ɵngcc3 from '@angular/cdk/platform';\nimport * as ɵngcc4 from '@angular/cdk/bidi';\nvar _c0 = [\"fixedEl\"];\nvar _c1 = [\"*\"];\n\nvar AffixRespondEvents = /*@__PURE__*/function (AffixRespondEvents) {\n  AffixRespondEvents[\"resize\"] = \"resize\";\n  AffixRespondEvents[\"scroll\"] = \"scroll\";\n  AffixRespondEvents[\"touchstart\"] = \"touchstart\";\n  AffixRespondEvents[\"touchmove\"] = \"touchmove\";\n  AffixRespondEvents[\"touchend\"] = \"touchend\";\n  AffixRespondEvents[\"pageshow\"] = \"pageshow\";\n  AffixRespondEvents[\"load\"] = \"LOAD\";\n  return AffixRespondEvents;\n}({});\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isTargetWindow(target) {\n  return typeof window !== 'undefined' && target === window;\n}\n\nfunction getTargetRect(target) {\n  return !isTargetWindow(target) ? target.getBoundingClientRect() : {\n    top: 0,\n    left: 0,\n    bottom: 0\n  };\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NZ_CONFIG_MODULE_NAME = 'affix';\nvar NZ_AFFIX_CLS_PREFIX = 'ant-affix';\nvar NZ_AFFIX_DEFAULT_SCROLL_TIME = 20;\n\nvar NzAffixComponent = /*@__PURE__*/function () {\n  var NzAffixComponent = /*#__PURE__*/function () {\n    function NzAffixComponent(el, doc, nzConfigService, scrollSrv, ngZone, platform, renderer, cdr, directionality) {\n      _classCallCheck(this, NzAffixComponent);\n\n      this.nzConfigService = nzConfigService;\n      this.scrollSrv = scrollSrv;\n      this.ngZone = ngZone;\n      this.platform = platform;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.directionality = directionality;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzChange = new EventEmitter();\n      this.dir = 'ltr';\n      this.positionChangeSubscription = Subscription.EMPTY;\n      this.offsetChanged$ = new ReplaySubject(1);\n      this.destroy$ = new Subject(); // The wrapper would stay at the original position as a placeholder.\n\n      this.placeholderNode = el.nativeElement;\n      this.document = doc;\n    }\n\n    _createClass(NzAffixComponent, [{\n      key: \"target\",\n      get: function get() {\n        var el = this.nzTarget;\n        return (typeof el === 'string' ? this.document.querySelector(el) : el) || window;\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this = this;\n\n        var _a;\n\n        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(function (direction) {\n          _this.dir = direction;\n\n          _this.registerListeners();\n\n          _this.updatePosition({});\n\n          _this.cdr.detectChanges();\n        });\n        this.dir = this.directionality.value;\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var nzOffsetBottom = changes.nzOffsetBottom,\n            nzOffsetTop = changes.nzOffsetTop,\n            nzTarget = changes.nzTarget;\n\n        if (nzOffsetBottom || nzOffsetTop) {\n          this.offsetChanged$.next();\n        }\n\n        if (nzTarget) {\n          this.registerListeners();\n        }\n      }\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        this.registerListeners();\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.removeListeners();\n      }\n    }, {\n      key: \"registerListeners\",\n      value: function registerListeners() {\n        var _this2 = this;\n\n        if (!this.platform.isBrowser) {\n          return;\n        }\n\n        this.removeListeners();\n        this.positionChangeSubscription = this.ngZone.runOutsideAngular(function () {\n          return merge.apply(void 0, _toConsumableArray(Object.keys(AffixRespondEvents).map(function (evName) {\n            return fromEvent(_this2.target, evName);\n          })).concat([_this2.offsetChanged$.pipe(takeUntil(_this2.destroy$), map(function () {\n            return {};\n          }))])).pipe(auditTime(NZ_AFFIX_DEFAULT_SCROLL_TIME)).subscribe(function (e) {\n            return _this2.updatePosition(e);\n          });\n        });\n        this.timeout = setTimeout(function () {\n          return _this2.updatePosition({});\n        });\n      }\n    }, {\n      key: \"removeListeners\",\n      value: function removeListeners() {\n        clearTimeout(this.timeout);\n        this.positionChangeSubscription.unsubscribe();\n        this.destroy$.next();\n        this.destroy$.complete();\n      }\n    }, {\n      key: \"getOffset\",\n      value: function getOffset(element, target) {\n        var elemRect = element.getBoundingClientRect();\n        var targetRect = getTargetRect(target);\n        var scrollTop = this.scrollSrv.getScroll(target, true);\n        var scrollLeft = this.scrollSrv.getScroll(target, false);\n        var docElem = this.document.body;\n        var clientTop = docElem.clientTop || 0;\n        var clientLeft = docElem.clientLeft || 0;\n        return {\n          top: elemRect.top - targetRect.top + scrollTop - clientTop,\n          left: elemRect.left - targetRect.left + scrollLeft - clientLeft,\n          width: elemRect.width,\n          height: elemRect.height\n        };\n      }\n    }, {\n      key: \"setAffixStyle\",\n      value: function setAffixStyle(e, affixStyle) {\n        var originalAffixStyle = this.affixStyle;\n        var isWindow = this.target === window;\n\n        if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {\n          return;\n        }\n\n        if (shallowEqual(originalAffixStyle, affixStyle)) {\n          return;\n        }\n\n        var fixed = !!affixStyle;\n        var wrapEl = this.fixedEl.nativeElement;\n        this.renderer.setStyle(wrapEl, 'cssText', getStyleAsText(affixStyle));\n        this.affixStyle = affixStyle;\n\n        if (fixed) {\n          wrapEl.classList.add(NZ_AFFIX_CLS_PREFIX);\n        } else {\n          wrapEl.classList.remove(NZ_AFFIX_CLS_PREFIX);\n        }\n\n        this.updateRtlClass();\n\n        if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {\n          this.nzChange.emit(fixed);\n        }\n      }\n    }, {\n      key: \"setPlaceholderStyle\",\n      value: function setPlaceholderStyle(placeholderStyle) {\n        var originalPlaceholderStyle = this.placeholderStyle;\n\n        if (shallowEqual(placeholderStyle, originalPlaceholderStyle)) {\n          return;\n        }\n\n        this.renderer.setStyle(this.placeholderNode, 'cssText', getStyleAsText(placeholderStyle));\n        this.placeholderStyle = placeholderStyle;\n      }\n    }, {\n      key: \"syncPlaceholderStyle\",\n      value: function syncPlaceholderStyle(e) {\n        if (!this.affixStyle) {\n          return;\n        }\n\n        this.renderer.setStyle(this.placeholderNode, 'cssText', '');\n        this.placeholderStyle = undefined;\n        var styleObj = {\n          width: this.placeholderNode.offsetWidth,\n          height: this.fixedEl.nativeElement.offsetHeight\n        };\n        this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), styleObj));\n        this.setPlaceholderStyle(styleObj);\n      }\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition(e) {\n        if (!this.platform.isBrowser) {\n          return;\n        }\n\n        var targetNode = this.target;\n        var offsetTop = this.nzOffsetTop;\n        var scrollTop = this.scrollSrv.getScroll(targetNode, true);\n        var elemOffset = this.getOffset(this.placeholderNode, targetNode);\n        var fixedNode = this.fixedEl.nativeElement;\n        var elemSize = {\n          width: fixedNode.offsetWidth,\n          height: fixedNode.offsetHeight\n        };\n        var offsetMode = {\n          top: false,\n          bottom: false\n        }; // Default to `offsetTop=0`.\n\n        if (typeof offsetTop !== 'number' && typeof this.nzOffsetBottom !== 'number') {\n          offsetMode.top = true;\n          offsetTop = 0;\n        } else {\n          offsetMode.top = typeof offsetTop === 'number';\n          offsetMode.bottom = typeof this.nzOffsetBottom === 'number';\n        }\n\n        var targetRect = getTargetRect(targetNode);\n        var targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;\n\n        if (scrollTop >= elemOffset.top - offsetTop && offsetMode.top) {\n          var width = elemOffset.width;\n          var top = targetRect.top + offsetTop;\n          this.setAffixStyle(e, {\n            position: 'fixed',\n            top: top,\n            left: targetRect.left + elemOffset.left,\n            width: width\n          });\n          this.setPlaceholderStyle({\n            width: width,\n            height: elemSize.height\n          });\n        } else if (scrollTop <= elemOffset.top + elemSize.height + this.nzOffsetBottom - targetInnerHeight && offsetMode.bottom) {\n          var targetBottomOffset = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;\n          var _width = elemOffset.width;\n          this.setAffixStyle(e, {\n            position: 'fixed',\n            bottom: targetBottomOffset + this.nzOffsetBottom,\n            left: targetRect.left + elemOffset.left,\n            width: _width\n          });\n          this.setPlaceholderStyle({\n            width: _width,\n            height: elemOffset.height\n          });\n        } else {\n          if (e.type === AffixRespondEvents.resize && this.affixStyle && this.affixStyle.position === 'fixed' && this.placeholderNode.offsetWidth) {\n            this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), {\n              width: this.placeholderNode.offsetWidth\n            }));\n          } else {\n            this.setAffixStyle(e);\n          }\n\n          this.setPlaceholderStyle();\n        }\n\n        if (e.type === 'resize') {\n          this.syncPlaceholderStyle(e);\n        }\n      }\n    }, {\n      key: \"updateRtlClass\",\n      value: function updateRtlClass() {\n        var wrapEl = this.fixedEl.nativeElement;\n\n        if (this.dir === 'rtl') {\n          if (wrapEl.classList.contains(NZ_AFFIX_CLS_PREFIX)) {\n            wrapEl.classList.add(\"\".concat(NZ_AFFIX_CLS_PREFIX, \"-rtl\"));\n          } else {\n            wrapEl.classList.remove(\"\".concat(NZ_AFFIX_CLS_PREFIX, \"-rtl\"));\n          }\n        } else {\n          wrapEl.classList.remove(\"\".concat(NZ_AFFIX_CLS_PREFIX, \"-rtl\"));\n        }\n      }\n    }]);\n\n    return NzAffixComponent;\n  }();\n\n  NzAffixComponent.ɵfac = function NzAffixComponent_Factory(t) {\n    return new (t || NzAffixComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NzConfigService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NzScrollService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8));\n  };\n\n  NzAffixComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: NzAffixComponent,\n    selectors: [[\"nz-affix\"]],\n    viewQuery: function NzAffixComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 3);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fixedEl = _t.first);\n      }\n    },\n    inputs: {\n      nzTarget: \"nzTarget\",\n      nzOffsetTop: \"nzOffsetTop\",\n      nzOffsetBottom: \"nzOffsetBottom\"\n    },\n    outputs: {\n      nzChange: \"nzChange\"\n    },\n    exportAs: [\"nzAffix\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[\"fixedEl\", \"\"]],\n    template: function NzAffixComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([WithConfig(), InputNumber(undefined), __metadata(\"design:type\", Object)], NzAffixComponent.prototype, \"nzOffsetTop\", void 0);\n\n  __decorate([WithConfig(), InputNumber(undefined), __metadata(\"design:type\", Object)], NzAffixComponent.prototype, \"nzOffsetBottom\", void 0);\n\n  return NzAffixComponent;\n}();\n\nvar NzAffixModule = /*@__PURE__*/function () {\n  var NzAffixModule = function NzAffixModule() {\n    _classCallCheck(this, NzAffixModule);\n  };\n\n  NzAffixModule.ɵfac = function NzAffixModule_Factory(t) {\n    return new (t || NzAffixModule)();\n  };\n\n  NzAffixModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: NzAffixModule\n  });\n  NzAffixModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, PlatformModule]]\n  });\n  return NzAffixModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzAffixModule, {\n    declarations: function declarations() {\n      return [NzAffixComponent];\n    },\n    imports: function imports() {\n      return [BidiModule, CommonModule, PlatformModule];\n    },\n    exports: function exports() {\n      return [NzAffixComponent];\n    }\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzAffixComponent, NzAffixModule }; //# sourceMappingURL=ng-zorro-antd-affix.js.map","map":null,"metadata":{},"sourceType":"module"}