{"ast":null,"code":"import _createForOfIteratorHelper from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar NzTreeNode = /*#__PURE__*/function () {\n  /**\n   * Init nzTreeNode\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  function NzTreeNode(option) {\n    var _this = this;\n\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var service = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, NzTreeNode);\n\n    this._title = '';\n    this.level = 0; // Parent Node\n\n    this.parentNode = null;\n    this._icon = '';\n    this._children = [];\n    this._isLeaf = false;\n    this._isChecked = false;\n    this._isSelectable = false;\n    this._isDisabled = false;\n    this._isDisableCheckbox = false;\n    this._isExpanded = false;\n    this._isHalfChecked = false;\n    this._isSelected = false;\n    this._isLoading = false;\n    this.canHide = false;\n    this.isMatched = false;\n    this.service = null;\n\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = []; // option params\n\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = !option.disabled && option.selected || false;\n    this._isLoading = false;\n    this.isMatched = false;\n    /**\n     * parent's checked status will affect children while initializing\n     */\n\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(function (nodeOptions) {\n        var s = _this.treeService;\n\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n\n        _this._children.push(new NzTreeNode(nodeOptions, _this));\n      });\n    }\n  }\n\n  _createClass(NzTreeNode, [{\n    key: \"treeService\",\n    get: function get() {\n      return this.service || this.parentNode && this.parentNode.treeService;\n    }\n    /**\n     * auto generate\n     * get\n     * set\n     */\n\n  }, {\n    key: \"title\",\n    get: function get() {\n      return this._title;\n    },\n    set: function set(value) {\n      this._title = value;\n      this.update();\n    }\n  }, {\n    key: \"icon\",\n    get: function get() {\n      return this._icon;\n    },\n    set: function set(value) {\n      this._icon = value;\n      this.update();\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    },\n    set: function set(value) {\n      this._children = value;\n      this.update();\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this._isLeaf;\n    },\n    set: function set(value) {\n      this._isLeaf = value;\n      this.update();\n    }\n  }, {\n    key: \"isChecked\",\n    get: function get() {\n      return this._isChecked;\n    },\n    set: function set(value) {\n      this._isChecked = value;\n      this.origin.checked = value;\n      this.afterValueChange('isChecked');\n    }\n  }, {\n    key: \"isHalfChecked\",\n    get: function get() {\n      return this._isHalfChecked;\n    },\n    set: function set(value) {\n      this._isHalfChecked = value;\n      this.afterValueChange('isHalfChecked');\n    }\n  }, {\n    key: \"isSelectable\",\n    get: function get() {\n      return this._isSelectable;\n    },\n    set: function set(value) {\n      this._isSelectable = value;\n      this.update();\n    }\n  }, {\n    key: \"isDisabled\",\n    get: function get() {\n      return this._isDisabled;\n    },\n    set: function set(value) {\n      this._isDisabled = value;\n      this.update();\n    }\n  }, {\n    key: \"isDisableCheckbox\",\n    get: function get() {\n      return this._isDisableCheckbox;\n    },\n    set: function set(value) {\n      this._isDisableCheckbox = value;\n      this.update();\n    }\n  }, {\n    key: \"isExpanded\",\n    get: function get() {\n      return this._isExpanded;\n    },\n    set: function set(value) {\n      this._isExpanded = value;\n      this.origin.expanded = value;\n      this.afterValueChange('isExpanded');\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"isSelected\",\n    get: function get() {\n      return this._isSelected;\n    },\n    set: function set(value) {\n      this._isSelected = value;\n      this.origin.selected = value;\n      this.afterValueChange('isSelected');\n    }\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._isLoading;\n    },\n    set: function set(value) {\n      this._isLoading = value;\n      this.update();\n    }\n  }, {\n    key: \"setSyncChecked\",\n    value: function setSyncChecked() {\n      var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var halfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.setChecked(checked, halfChecked);\n\n      if (this.treeService && !this.treeService.isCheckStrictly) {\n        this.treeService.conduct(this);\n      }\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked() {\n      var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var halfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.origin.checked = checked;\n      this.isChecked = checked;\n      this.isHalfChecked = halfChecked;\n    }\n  }, {\n    key: \"setExpanded\",\n    value: function setExpanded(value) {\n      this._isExpanded = value;\n      this.origin.expanded = value;\n      this.afterValueChange('isExpanded');\n    }\n  }, {\n    key: \"getParentNode\",\n    value: function getParentNode() {\n      return this.parentNode;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this.children;\n    }\n    /**\n     * Support appending child nodes by position. Leaf node cannot be appended.\n     */\n\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var _this2 = this;\n\n      var childPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      if (!this.isLeaf) {\n        children.forEach(function (node) {\n          var refreshLevel = function refreshLevel(n) {\n            n.getChildren().forEach(function (c) {\n              c.level = c.getParentNode().level + 1; // flush origin\n\n              c.origin.level = c.level;\n              refreshLevel(c);\n            });\n          };\n\n          var child = node;\n\n          if (child instanceof NzTreeNode) {\n            child.parentNode = _this2;\n          } else {\n            child = new NzTreeNode(node, _this2);\n          }\n\n          child.level = _this2.level + 1;\n          child.origin.level = child.level;\n          refreshLevel(child);\n\n          try {\n            childPos === -1 ? _this2.children.push(child) : _this2.children.splice(childPos, 0, child); // flush origin\n          } catch (e) {}\n        });\n        this.origin.children = this.getChildren().map(function (v) {\n          return v.origin;\n        }); // remove loading state\n\n        this.isLoading = false;\n      }\n\n      this.afterValueChange('addChildren');\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"clearChildren\",\n    value: function clearChildren() {\n      // refresh checked state\n      this.afterValueChange('clearChildren');\n      this.children = [];\n      this.origin.children = [];\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this3 = this;\n\n      var parentNode = this.getParentNode();\n\n      if (parentNode) {\n        parentNode.children = parentNode.getChildren().filter(function (v) {\n          return v.key !== _this3.key;\n        });\n        parentNode.origin.children = parentNode.origin.children.filter(function (v) {\n          return v.key !== _this3.key;\n        });\n        this.afterValueChange('remove');\n        this.afterValueChange('reRender');\n      }\n    }\n  }, {\n    key: \"afterValueChange\",\n    value: function afterValueChange(key) {\n      if (this.treeService) {\n        switch (key) {\n          case 'isChecked':\n            this.treeService.setCheckedNodeList(this);\n            break;\n\n          case 'isHalfChecked':\n            this.treeService.setHalfCheckedNodeList(this);\n            break;\n\n          case 'isExpanded':\n            this.treeService.setExpandedNodeList(this);\n            break;\n\n          case 'isSelected':\n            this.treeService.setNodeActive(this);\n            break;\n\n          case 'clearChildren':\n            this.treeService.afterRemove(this.getChildren());\n            break;\n\n          case 'remove':\n            this.treeService.afterRemove([this]);\n            break;\n\n          case 'reRender':\n            this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(function (v) {\n              return v.key;\n            }));\n            break;\n        }\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.component) {\n        this.component.markForCheck();\n      }\n    }\n  }]);\n\n  return NzTreeNode;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isCheckDisabled(node) {\n  var isDisabled = node.isDisabled,\n      isDisableCheckbox = node.isDisableCheckbox;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nfunction isInArray(needle, haystack) {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nfunction getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\n\nfunction getKey(key, pos) {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\n\n\nfunction _flattenTreeData() {\n  var treeNodeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  var flattenList = [];\n\n  function dig(list) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return list.map(function (treeNode, index) {\n      var pos = getPosition(parent ? parent.pos : '0', index);\n      var mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]);\n      treeNode.isEnd = [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1]); // Add FlattenDataNode into list\n      // TODO: only need data here.\n\n      var flattenNode = {\n        parent: parent,\n        pos: pos,\n        children: [],\n        data: treeNode,\n        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]),\n        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1])\n      };\n      flattenList.push(flattenNode); // Loop treeNode children\n\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n\nvar NzTreeBaseService = /*@__PURE__*/function () {\n  var NzTreeBaseService = /*#__PURE__*/function () {\n    function NzTreeBaseService() {\n      _classCallCheck(this, NzTreeBaseService);\n\n      this.DRAG_SIDE_RANGE = 0.25;\n      this.DRAG_MIN_GAP = 2;\n      this.isCheckStrictly = false;\n      this.isMultiple = false;\n      this.rootNodes = [];\n      this.flattenNodes$ = new BehaviorSubject([]);\n      this.selectedNodeList = [];\n      this.expandedNodeList = [];\n      this.checkedNodeList = [];\n      this.halfCheckedNodeList = [];\n      this.matchedNodeList = [];\n    }\n    /**\n     * reset tree nodes will clear default node list\n     */\n\n\n    _createClass(NzTreeBaseService, [{\n      key: \"initTree\",\n      value: function initTree(nzNodes) {\n        this.rootNodes = nzNodes;\n        this.expandedNodeList = [];\n        this.selectedNodeList = [];\n        this.halfCheckedNodeList = [];\n        this.checkedNodeList = [];\n        this.matchedNodeList = [];\n      }\n    }, {\n      key: \"flattenTreeData\",\n      value: function flattenTreeData(nzNodes) {\n        var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.flattenNodes$.next(_flattenTreeData(nzNodes, expandedKeys).map(function (item) {\n          return item.data;\n        }));\n      }\n    }, {\n      key: \"getSelectedNode\",\n      value: function getSelectedNode() {\n        return this.selectedNode;\n      }\n      /**\n       * get some list\n       */\n\n    }, {\n      key: \"getSelectedNodeList\",\n      value: function getSelectedNodeList() {\n        return this.conductNodeState('select');\n      }\n      /**\n       * return checked nodes\n       */\n\n    }, {\n      key: \"getCheckedNodeList\",\n      value: function getCheckedNodeList() {\n        return this.conductNodeState('check');\n      }\n    }, {\n      key: \"getHalfCheckedNodeList\",\n      value: function getHalfCheckedNodeList() {\n        return this.conductNodeState('halfCheck');\n      }\n      /**\n       * return expanded nodes\n       */\n\n    }, {\n      key: \"getExpandedNodeList\",\n      value: function getExpandedNodeList() {\n        return this.conductNodeState('expand');\n      }\n      /**\n       * return search matched nodes\n       */\n\n    }, {\n      key: \"getMatchedNodeList\",\n      value: function getMatchedNodeList() {\n        return this.conductNodeState('match');\n      }\n    }, {\n      key: \"isArrayOfNzTreeNode\",\n      value: function isArrayOfNzTreeNode(value) {\n        return value.every(function (item) {\n          return item instanceof NzTreeNode;\n        });\n      }\n      /**\n       * set drag node\n       */\n\n    }, {\n      key: \"setSelectedNode\",\n      value: function setSelectedNode(node) {\n        this.selectedNode = node;\n      }\n      /**\n       * set node selected status\n       */\n\n    }, {\n      key: \"setNodeActive\",\n      value: function setNodeActive(node) {\n        if (!this.isMultiple && node.isSelected) {\n          this.selectedNodeList.forEach(function (n) {\n            if (node.key !== n.key) {\n              // reset other nodes\n              n.isSelected = false;\n            }\n          }); // single mode: remove pre node\n\n          this.selectedNodeList = [];\n        }\n\n        this.setSelectedNodeList(node, this.isMultiple);\n      }\n      /**\n       * add or remove node to selectedNodeList\n       */\n\n    }, {\n      key: \"setSelectedNodeList\",\n      value: function setSelectedNodeList(node) {\n        var isMultiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var index = this.getIndexOfArray(this.selectedNodeList, node.key);\n\n        if (isMultiple) {\n          if (node.isSelected && index === -1) {\n            this.selectedNodeList.push(node);\n          }\n        } else {\n          if (node.isSelected && index === -1) {\n            this.selectedNodeList = [node];\n          }\n        }\n\n        if (!node.isSelected) {\n          this.selectedNodeList = this.selectedNodeList.filter(function (n) {\n            return n.key !== node.key;\n          });\n        }\n      }\n      /**\n       * merge checked nodes\n       */\n\n    }, {\n      key: \"setHalfCheckedNodeList\",\n      value: function setHalfCheckedNodeList(node) {\n        var index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n\n        if (node.isHalfChecked && index === -1) {\n          this.halfCheckedNodeList.push(node);\n        } else if (!node.isHalfChecked && index > -1) {\n          this.halfCheckedNodeList = this.halfCheckedNodeList.filter(function (n) {\n            return node.key !== n.key;\n          });\n        }\n      }\n    }, {\n      key: \"setCheckedNodeList\",\n      value: function setCheckedNodeList(node) {\n        var index = this.getIndexOfArray(this.checkedNodeList, node.key);\n\n        if (node.isChecked && index === -1) {\n          this.checkedNodeList.push(node);\n        } else if (!node.isChecked && index > -1) {\n          this.checkedNodeList = this.checkedNodeList.filter(function (n) {\n            return node.key !== n.key;\n          });\n        }\n      }\n      /**\n       * conduct checked/selected/expanded keys\n       */\n\n    }, {\n      key: \"conductNodeState\",\n      value: function conductNodeState() {\n        var _this4 = this;\n\n        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'check';\n        var resultNodesList = [];\n\n        switch (type) {\n          case 'select':\n            resultNodesList = this.selectedNodeList;\n            break;\n\n          case 'expand':\n            resultNodesList = this.expandedNodeList;\n            break;\n\n          case 'match':\n            resultNodesList = this.matchedNodeList;\n            break;\n\n          case 'check':\n            resultNodesList = this.checkedNodeList;\n\n            var isIgnore = function isIgnore(node) {\n              var parentNode = node.getParentNode();\n\n              if (parentNode) {\n                if (_this4.checkedNodeList.findIndex(function (n) {\n                  return n.key === parentNode.key;\n                }) > -1) {\n                  return true;\n                } else {\n                  return isIgnore(parentNode);\n                }\n              }\n\n              return false;\n            }; // merge checked\n\n\n            if (!this.isCheckStrictly) {\n              resultNodesList = this.checkedNodeList.filter(function (n) {\n                return !isIgnore(n);\n              });\n            }\n\n            break;\n\n          case 'halfCheck':\n            if (!this.isCheckStrictly) {\n              resultNodesList = this.halfCheckedNodeList;\n            }\n\n            break;\n        }\n\n        return resultNodesList;\n      }\n      /**\n       * set expanded nodes\n       */\n\n    }, {\n      key: \"setExpandedNodeList\",\n      value: function setExpandedNodeList(node) {\n        if (node.isLeaf) {\n          return;\n        }\n\n        var index = this.getIndexOfArray(this.expandedNodeList, node.key);\n\n        if (node.isExpanded && index === -1) {\n          this.expandedNodeList.push(node);\n        } else if (!node.isExpanded && index > -1) {\n          this.expandedNodeList.splice(index, 1);\n        }\n      }\n    }, {\n      key: \"setMatchedNodeList\",\n      value: function setMatchedNodeList(node) {\n        var index = this.getIndexOfArray(this.matchedNodeList, node.key);\n\n        if (node.isMatched && index === -1) {\n          this.matchedNodeList.push(node);\n        } else if (!node.isMatched && index > -1) {\n          this.matchedNodeList.splice(index, 1);\n        }\n      }\n      /**\n       * check state\n       * @param isCheckStrictly\n       */\n\n    }, {\n      key: \"refreshCheckState\",\n      value: function refreshCheckState() {\n        var _this5 = this;\n\n        var isCheckStrictly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (isCheckStrictly) {\n          return;\n        }\n\n        this.checkedNodeList.forEach(function (node) {\n          _this5.conduct(node, isCheckStrictly);\n        });\n      } // reset other node checked state based current node\n\n    }, {\n      key: \"conduct\",\n      value: function conduct(node) {\n        var isCheckStrictly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var isChecked = node.isChecked;\n\n        if (node && !isCheckStrictly) {\n          this.conductUp(node);\n          this.conductDown(node, isChecked);\n        }\n      }\n      /**\n       * 1、children half checked\n       * 2、children all checked, parent checked\n       * 3、no children checked\n       */\n\n    }, {\n      key: \"conductUp\",\n      value: function conductUp(node) {\n        var parentNode = node.getParentNode();\n\n        if (parentNode) {\n          if (!isCheckDisabled(parentNode)) {\n            if (parentNode.children.every(function (child) {\n              return isCheckDisabled(child) || !child.isHalfChecked && child.isChecked;\n            })) {\n              parentNode.isChecked = true;\n              parentNode.isHalfChecked = false;\n            } else if (parentNode.children.some(function (child) {\n              return child.isHalfChecked || child.isChecked;\n            })) {\n              parentNode.isChecked = false;\n              parentNode.isHalfChecked = true;\n            } else {\n              parentNode.isChecked = false;\n              parentNode.isHalfChecked = false;\n            }\n          }\n\n          this.setCheckedNodeList(parentNode);\n          this.setHalfCheckedNodeList(parentNode);\n          this.conductUp(parentNode);\n        }\n      }\n      /**\n       * reset child check state\n       */\n\n    }, {\n      key: \"conductDown\",\n      value: function conductDown(node, value) {\n        var _this6 = this;\n\n        if (!isCheckDisabled(node)) {\n          node.isChecked = value;\n          node.isHalfChecked = false;\n          this.setCheckedNodeList(node);\n          this.setHalfCheckedNodeList(node);\n          node.children.forEach(function (n) {\n            _this6.conductDown(n, value);\n          });\n        }\n      }\n      /**\n       * flush after delete node\n       */\n\n    }, {\n      key: \"afterRemove\",\n      value: function afterRemove(nodes) {\n        var _this7 = this;\n\n        // to reset selectedNodeList & expandedNodeList\n        var loopNode = function loopNode(node) {\n          // remove selected node\n          _this7.selectedNodeList = _this7.selectedNodeList.filter(function (n) {\n            return n.key !== node.key;\n          }); // remove expanded node\n\n          _this7.expandedNodeList = _this7.expandedNodeList.filter(function (n) {\n            return n.key !== node.key;\n          }); // remove checked node\n\n          _this7.checkedNodeList = _this7.checkedNodeList.filter(function (n) {\n            return n.key !== node.key;\n          });\n\n          if (node.children) {\n            node.children.forEach(function (child) {\n              loopNode(child);\n            });\n          }\n        };\n\n        nodes.forEach(function (n) {\n          loopNode(n);\n        });\n        this.refreshCheckState(this.isCheckStrictly);\n      }\n      /**\n       * drag event\n       */\n\n    }, {\n      key: \"refreshDragNode\",\n      value: function refreshDragNode(node) {\n        var _this8 = this;\n\n        if (node.children.length === 0) {\n          // until root\n          this.conductUp(node);\n        } else {\n          node.children.forEach(function (child) {\n            _this8.refreshDragNode(child);\n          });\n        }\n      } // reset node level\n\n    }, {\n      key: \"resetNodeLevel\",\n      value: function resetNodeLevel(node) {\n        var parentNode = node.getParentNode();\n\n        if (parentNode) {\n          node.level = parentNode.level + 1;\n        } else {\n          node.level = 0;\n        }\n\n        var _iterator = _createForOfIteratorHelper(node.children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var child = _step.value;\n            this.resetNodeLevel(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }, {\n      key: \"calcDropPosition\",\n      value: function calcDropPosition(event) {\n        var clientY = event.clientY; // to fix firefox undefined\n\n        var _event$target$getBoun = event.target.getBoundingClientRect(),\n            top = _event$target$getBoun.top,\n            bottom = _event$target$getBoun.bottom,\n            height = _event$target$getBoun.height;\n\n        var des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n        if (clientY <= top + des) {\n          return -1;\n        } else if (clientY >= bottom - des) {\n          return 1;\n        }\n\n        return 0;\n      }\n      /**\n       * drop\n       * 0: inner -1: pre 1: next\n       */\n\n    }, {\n      key: \"dropAndApply\",\n      value: function dropAndApply(targetNode) {\n        var _this9 = this;\n\n        var dragPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n        if (!targetNode || dragPos > 1) {\n          return;\n        }\n\n        var treeService = targetNode.treeService;\n        var targetParent = targetNode.getParentNode();\n        var isSelectedRootNode = this.selectedNode.getParentNode(); // remove the dragNode\n\n        if (isSelectedRootNode) {\n          isSelectedRootNode.children = isSelectedRootNode.children.filter(function (n) {\n            return n.key !== _this9.selectedNode.key;\n          });\n        } else {\n          this.rootNodes = this.rootNodes.filter(function (n) {\n            return n.key !== _this9.selectedNode.key;\n          });\n        }\n\n        switch (dragPos) {\n          case 0:\n            targetNode.addChildren([this.selectedNode]);\n            this.resetNodeLevel(targetNode);\n            break;\n\n          case -1:\n          case 1:\n            var tIndex = dragPos === 1 ? 1 : 0;\n\n            if (targetParent) {\n              targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n              var parentNode = this.selectedNode.getParentNode();\n\n              if (parentNode) {\n                this.resetNodeLevel(parentNode);\n              }\n            } else {\n              var targetIndex = this.rootNodes.indexOf(targetNode) + tIndex; // Insert root node.\n\n              this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n              this.rootNodes[targetIndex].parentNode = null;\n              this.resetNodeLevel(this.rootNodes[targetIndex]);\n            }\n\n            break;\n        } // flush all nodes\n\n\n        this.rootNodes.forEach(function (child) {\n          if (!child.treeService) {\n            child.service = treeService;\n          }\n\n          _this9.refreshDragNode(child);\n        });\n      }\n      /**\n       * emit Structure\n       * eventName\n       * node\n       * event: MouseEvent / DragEvent\n       * dragNode\n       */\n\n    }, {\n      key: \"formatEvent\",\n      value: function formatEvent(eventName, node, event) {\n        var emitStructure = {\n          eventName: eventName,\n          node: node,\n          event: event\n        };\n\n        switch (eventName) {\n          case 'dragstart':\n          case 'dragenter':\n          case 'dragover':\n          case 'dragleave':\n          case 'drop':\n          case 'dragend':\n            Object.assign(emitStructure, {\n              dragNode: this.getSelectedNode()\n            });\n            break;\n\n          case 'click':\n          case 'dblclick':\n            Object.assign(emitStructure, {\n              selectedKeys: this.selectedNodeList\n            });\n            Object.assign(emitStructure, {\n              nodes: this.selectedNodeList\n            });\n            Object.assign(emitStructure, {\n              keys: this.selectedNodeList.map(function (n) {\n                return n.key;\n              })\n            });\n            break;\n\n          case 'check':\n            var checkedNodeList = this.getCheckedNodeList();\n            Object.assign(emitStructure, {\n              checkedKeys: checkedNodeList\n            });\n            Object.assign(emitStructure, {\n              nodes: checkedNodeList\n            });\n            Object.assign(emitStructure, {\n              keys: checkedNodeList.map(function (n) {\n                return n.key;\n              })\n            });\n            break;\n\n          case 'search':\n            Object.assign(emitStructure, {\n              matchedKeys: this.getMatchedNodeList()\n            });\n            Object.assign(emitStructure, {\n              nodes: this.getMatchedNodeList()\n            });\n            Object.assign(emitStructure, {\n              keys: this.getMatchedNodeList().map(function (n) {\n                return n.key;\n              })\n            });\n            break;\n\n          case 'expand':\n            Object.assign(emitStructure, {\n              nodes: this.expandedNodeList\n            });\n            Object.assign(emitStructure, {\n              keys: this.expandedNodeList.map(function (n) {\n                return n.key;\n              })\n            });\n            break;\n        }\n\n        return emitStructure;\n      }\n      /**\n       * New functions for flatten nodes\n       */\n\n    }, {\n      key: \"getIndexOfArray\",\n      value: function getIndexOfArray(list, key) {\n        return list.findIndex(function (v) {\n          return v.key === key;\n        });\n      }\n      /**\n       * Render by nzCheckedKeys\n       * When keys equals null, just render with checkStrictly\n       * @param keys\n       * @param checkStrictly\n       */\n\n    }, {\n      key: \"conductCheck\",\n      value: function conductCheck(keys, checkStrictly) {\n        this.checkedNodeList = [];\n        this.halfCheckedNodeList = [];\n\n        var calc = function calc(nodes) {\n          nodes.forEach(function (node) {\n            if (keys === null) {\n              // render tree if no default checked keys found\n              node.isChecked = !!node.origin.checked;\n            } else {\n              if (isInArray(node.key, keys || [])) {\n                node.isChecked = true;\n                node.isHalfChecked = false;\n              } else {\n                node.isChecked = false;\n                node.isHalfChecked = false;\n              }\n            }\n\n            if (node.children.length > 0) {\n              calc(node.children);\n            }\n          });\n        };\n\n        calc(this.rootNodes);\n        this.refreshCheckState(checkStrictly);\n      }\n    }, {\n      key: \"conductExpandedKeys\",\n      value: function conductExpandedKeys() {\n        var _this10 = this;\n\n        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var expandedKeySet = new Set(keys === true ? [] : keys);\n        this.expandedNodeList = [];\n\n        var calc = function calc(nodes) {\n          nodes.forEach(function (node) {\n            node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n\n            if (node.isExpanded) {\n              _this10.setExpandedNodeList(node);\n            }\n\n            if (node.children.length > 0) {\n              calc(node.children);\n            }\n          });\n        };\n\n        calc(this.rootNodes);\n      }\n    }, {\n      key: \"conductSelectedKeys\",\n      value: function conductSelectedKeys(keys, isMulti) {\n        var _this11 = this;\n\n        this.selectedNodeList.forEach(function (node) {\n          return node.isSelected = false;\n        });\n        this.selectedNodeList = [];\n\n        var calc = function calc(nodes) {\n          return nodes.every(function (node) {\n            if (isInArray(node.key, keys)) {\n              node.isSelected = true;\n\n              _this11.setSelectedNodeList(node);\n\n              if (!isMulti) {\n                // if not support multi select\n                return false;\n              }\n            } else {\n              node.isSelected = false;\n            }\n\n            if (node.children.length > 0) {\n              // Recursion\n              return calc(node.children);\n            }\n\n            return true;\n          });\n        };\n\n        calc(this.rootNodes);\n      }\n      /**\n       * Expand parent nodes by child node\n       * @param node\n       */\n\n    }, {\n      key: \"expandNodeAllParentBySearch\",\n      value: function expandNodeAllParentBySearch(node) {\n        var _this12 = this;\n\n        var calc = function calc(n) {\n          if (n) {\n            n.canHide = false;\n            n.setExpanded(true);\n\n            _this12.setExpandedNodeList(n);\n\n            if (n.getParentNode()) {\n              return calc(n.getParentNode());\n            }\n          }\n        };\n\n        calc(node.getParentNode());\n      }\n    }]);\n\n    return NzTreeBaseService;\n  }();\n\n  NzTreeBaseService.ɵfac = function NzTreeBaseService_Factory(t) {\n    return new (t || NzTreeBaseService)();\n  };\n\n  NzTreeBaseService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: NzTreeBaseService,\n    factory: NzTreeBaseService.ɵfac\n  });\n  return NzTreeBaseService;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nvar NzTreeBase = /*#__PURE__*/function () {\n  function NzTreeBase(nzTreeService) {\n    _classCallCheck(this, NzTreeBase);\n\n    this.nzTreeService = nzTreeService;\n  }\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n\n\n  _createClass(NzTreeBase, [{\n    key: \"coerceTreeNodes\",\n    value: function coerceTreeNodes(value) {\n      var _this13 = this;\n\n      var nodes = [];\n\n      if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n        // has not been new NzTreeNode\n        nodes = value.map(function (item) {\n          return new NzTreeNode(item, null, _this13.nzTreeService);\n        });\n      } else {\n        nodes = value.map(function (item) {\n          item.service = _this13.nzTreeService;\n          return item;\n        });\n      }\n\n      return nodes;\n    }\n    /**\n     * Get all nodes({@link NzTreeNode})\n     */\n\n  }, {\n    key: \"getTreeNodes\",\n    value: function getTreeNodes() {\n      return this.nzTreeService.rootNodes;\n    }\n    /**\n     * Get {@link NzTreeNode} with key\n     */\n\n  }, {\n    key: \"getTreeNodeByKey\",\n    value: function getTreeNodeByKey(key) {\n      // flat tree nodes\n      var nodes = [];\n\n      var getNode = function getNode(node) {\n        nodes.push(node);\n        node.getChildren().forEach(function (n) {\n          getNode(n);\n        });\n      };\n\n      this.getTreeNodes().forEach(function (n) {\n        getNode(n);\n      });\n      return nodes.find(function (n) {\n        return n.key === key;\n      }) || null;\n    }\n    /**\n     * Get checked nodes(merged)\n     */\n\n  }, {\n    key: \"getCheckedNodeList\",\n    value: function getCheckedNodeList() {\n      return this.nzTreeService.getCheckedNodeList();\n    }\n    /**\n     * Get selected nodes\n     */\n\n  }, {\n    key: \"getSelectedNodeList\",\n    value: function getSelectedNodeList() {\n      return this.nzTreeService.getSelectedNodeList();\n    }\n    /**\n     * Get half checked nodes\n     */\n\n  }, {\n    key: \"getHalfCheckedNodeList\",\n    value: function getHalfCheckedNodeList() {\n      return this.nzTreeService.getHalfCheckedNodeList();\n    }\n    /**\n     * Get expanded nodes\n     */\n\n  }, {\n    key: \"getExpandedNodeList\",\n    value: function getExpandedNodeList() {\n      return this.nzTreeService.getExpandedNodeList();\n    }\n    /**\n     * Get matched nodes(if nzSearchValue is not null)\n     */\n\n  }, {\n    key: \"getMatchedNodeList\",\n    value: function getMatchedNodeList() {\n      return this.nzTreeService.getMatchedNodeList();\n    }\n  }]);\n\n  return NzTreeBase;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, _flattenTreeData as flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray }; //# sourceMappingURL=ng-zorro-antd-core-tree.js.map","map":null,"metadata":{},"sourceType":"module"}