{"ast":null,"code":"import _classCallCheck from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:/qiankun/qiankun-angular/node_modules/@angular-builders/custom-webpack/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ɵɵdefineInjectable, ɵɵinject, NgZone, RendererFactory2, Injectable, Inject } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { auditTime, finalize, map, filter, startWith, distinctUntilChanged } from 'rxjs/operators';\nimport { environment } from 'ng-zorro-antd/core/environments';\nimport { getEventPosition, isTouchEvent } from 'ng-zorro-antd/core/util';\nimport { DOCUMENT } from '@angular/common';\nimport { reqAnimFrame } from 'ng-zorro-antd/core/polyfill';\nimport { MediaMatcher } from '@angular/cdk/layout';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/layout';\n\nvar NOOP = function NOOP() {};\n\nvar ɵ0 = NOOP;\n\nvar NzResizeService = /*@__PURE__*/function () {\n  var NzResizeService = /*#__PURE__*/function () {\n    function NzResizeService(ngZone, rendererFactory2) {\n      var _this = this;\n\n      _classCallCheck(this, NzResizeService);\n\n      this.ngZone = ngZone;\n      this.rendererFactory2 = rendererFactory2;\n      this.resizeSource$ = new Subject();\n      this.listeners = 0;\n      this.disposeHandle = NOOP;\n\n      this.handler = function () {\n        _this.ngZone.run(function () {\n          _this.resizeSource$.next();\n        });\n      };\n\n      this.renderer = this.rendererFactory2.createRenderer(null, null);\n    }\n\n    _createClass(NzResizeService, [{\n      key: \"subscribe\",\n      value: function subscribe() {\n        var _this2 = this;\n\n        this.registerListener();\n        return this.resizeSource$.pipe(auditTime(16), finalize(function () {\n          return _this2.unregisterListener();\n        }));\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe() {\n        this.unregisterListener();\n      }\n    }, {\n      key: \"registerListener\",\n      value: function registerListener() {\n        var _this3 = this;\n\n        if (this.listeners === 0) {\n          this.ngZone.runOutsideAngular(function () {\n            _this3.disposeHandle = _this3.renderer.listen('window', 'resize', _this3.handler);\n          });\n        }\n\n        this.listeners += 1;\n      }\n    }, {\n      key: \"unregisterListener\",\n      value: function unregisterListener() {\n        this.listeners -= 1;\n\n        if (this.listeners === 0) {\n          this.disposeHandle();\n          this.disposeHandle = NOOP;\n        }\n      }\n    }]);\n\n    return NzResizeService;\n  }();\n\n  NzResizeService.ɵfac = function NzResizeService_Factory(t) {\n    return new (t || NzResizeService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2));\n  };\n\n  NzResizeService.ɵprov = ɵɵdefineInjectable({\n    factory: function NzResizeService_Factory() {\n      return new NzResizeService(ɵɵinject(NgZone), ɵɵinject(RendererFactory2));\n    },\n    token: NzResizeService,\n    providedIn: \"root\"\n  });\n  return NzResizeService;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * When running in test, singletons should not be destroyed. So we keep references of singletons\n * in this global variable.\n */\n\n\nvar testSingleRegistry = new Map();\n\nvar NzSingletonService = /*@__PURE__*/function () {\n  var NzSingletonService = /*#__PURE__*/function () {\n    function NzSingletonService() {\n      _classCallCheck(this, NzSingletonService);\n\n      /**\n       * This registry is used to register singleton in dev mode.\n       * So that singletons get destroyed when hot module reload happens.\n       *\n       * This works in prod mode too but with no specific effect.\n       */\n      this._singletonRegistry = new Map();\n    }\n\n    _createClass(NzSingletonService, [{\n      key: \"singletonRegistry\",\n      get: function get() {\n        return environment.isTestMode ? testSingleRegistry : this._singletonRegistry;\n      }\n    }, {\n      key: \"registerSingletonWithKey\",\n      value: function registerSingletonWithKey(key, target) {\n        var alreadyHave = this.singletonRegistry.has(key);\n        var item = alreadyHave ? this.singletonRegistry.get(key) : this.withNewTarget(target);\n\n        if (!alreadyHave) {\n          this.singletonRegistry.set(key, item);\n        }\n      }\n    }, {\n      key: \"getSingletonWithKey\",\n      value: function getSingletonWithKey(key) {\n        return this.singletonRegistry.has(key) ? this.singletonRegistry.get(key).target : null;\n      }\n    }, {\n      key: \"withNewTarget\",\n      value: function withNewTarget(target) {\n        return {\n          target: target\n        };\n      }\n    }]);\n\n    return NzSingletonService;\n  }();\n\n  NzSingletonService.ɵfac = function NzSingletonService_Factory(t) {\n    return new (t || NzSingletonService)();\n  };\n\n  NzSingletonService.ɵprov = ɵɵdefineInjectable({\n    factory: function NzSingletonService_Factory() {\n      return new NzSingletonService();\n    },\n    token: NzSingletonService,\n    providedIn: \"root\"\n  });\n  return NzSingletonService;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction getPagePosition(event) {\n  var e = getEventPosition(event);\n  return {\n    x: e.pageX,\n    y: e.pageY\n  };\n}\n\nvar NzDragService = /*@__PURE__*/function () {\n  var NzDragService = /*#__PURE__*/function () {\n    function NzDragService(rendererFactory2) {\n      _classCallCheck(this, NzDragService);\n\n      this.draggingThreshold = 5;\n      this.currentDraggingSequence = null;\n      this.currentStartingPoint = null;\n      this.handleRegistry = new Set();\n      this.renderer = rendererFactory2.createRenderer(null, null);\n    }\n\n    _createClass(NzDragService, [{\n      key: \"requestDraggingSequence\",\n      value: function requestDraggingSequence(event) {\n        var _this4 = this;\n\n        if (!this.handleRegistry.size) {\n          this.registerDraggingHandler(isTouchEvent(event));\n        } // Complete last dragging sequence if a new target is dragged.\n\n\n        if (this.currentDraggingSequence) {\n          this.currentDraggingSequence.complete();\n        }\n\n        this.currentStartingPoint = getPagePosition(event);\n        this.currentDraggingSequence = new Subject();\n        return this.currentDraggingSequence.pipe(map(function (e) {\n          return {\n            x: e.pageX - _this4.currentStartingPoint.x,\n            y: e.pageY - _this4.currentStartingPoint.y\n          };\n        }), filter(function (e) {\n          return Math.abs(e.x) > _this4.draggingThreshold || Math.abs(e.y) > _this4.draggingThreshold;\n        }), finalize(function () {\n          return _this4.teardownDraggingSequence();\n        }));\n      }\n    }, {\n      key: \"registerDraggingHandler\",\n      value: function registerDraggingHandler(isTouch) {\n        var _this5 = this;\n\n        if (isTouch) {\n          this.handleRegistry.add({\n            teardown: this.renderer.listen('document', 'touchmove', function (e) {\n              if (_this5.currentDraggingSequence) {\n                _this5.currentDraggingSequence.next(e.touches[0] || e.changedTouches[0]);\n              }\n            })\n          });\n          this.handleRegistry.add({\n            teardown: this.renderer.listen('document', 'touchend', function () {\n              if (_this5.currentDraggingSequence) {\n                _this5.currentDraggingSequence.complete();\n              }\n            })\n          });\n        } else {\n          this.handleRegistry.add({\n            teardown: this.renderer.listen('document', 'mousemove', function (e) {\n              if (_this5.currentDraggingSequence) {\n                _this5.currentDraggingSequence.next(e);\n              }\n            })\n          });\n          this.handleRegistry.add({\n            teardown: this.renderer.listen('document', 'mouseup', function () {\n              if (_this5.currentDraggingSequence) {\n                _this5.currentDraggingSequence.complete();\n              }\n            })\n          });\n        }\n      }\n    }, {\n      key: \"teardownDraggingSequence\",\n      value: function teardownDraggingSequence() {\n        this.currentDraggingSequence = null;\n      }\n    }]);\n\n    return NzDragService;\n  }();\n\n  NzDragService.ɵfac = function NzDragService_Factory(t) {\n    return new (t || NzDragService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2));\n  };\n\n  NzDragService.ɵprov = ɵɵdefineInjectable({\n    factory: function NzDragService_Factory() {\n      return new NzDragService(ɵɵinject(RendererFactory2));\n    },\n    token: NzDragService,\n    providedIn: \"root\"\n  });\n  return NzDragService;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction easeInOutCubic(t, b, c, d) {\n  var cc = c - b;\n  var tt = t / (d / 2);\n\n  if (tt < 1) {\n    return cc / 2 * tt * tt * tt + b;\n  } else {\n    return cc / 2 * ((tt -= 2) * tt * tt + 2) + b;\n  }\n}\n\nvar NzScrollService = /*@__PURE__*/function () {\n  var NzScrollService = /*#__PURE__*/function () {\n    function NzScrollService(doc) {\n      _classCallCheck(this, NzScrollService);\n\n      this.doc = doc;\n    }\n    /** Set the position of the scroll bar of `el`. */\n\n\n    _createClass(NzScrollService, [{\n      key: \"setScrollTop\",\n      value: function setScrollTop(el) {\n        var topValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n        if (el === window) {\n          this.doc.body.scrollTop = topValue;\n          this.doc.documentElement.scrollTop = topValue;\n        } else {\n          el.scrollTop = topValue;\n        }\n      }\n      /** Get position of `el` against window. */\n\n    }, {\n      key: \"getOffset\",\n      value: function getOffset(el) {\n        var ret = {\n          top: 0,\n          left: 0\n        };\n\n        if (!el || !el.getClientRects().length) {\n          return ret;\n        }\n\n        var rect = el.getBoundingClientRect();\n\n        if (rect.width || rect.height) {\n          var doc = el.ownerDocument.documentElement;\n          ret.top = rect.top - doc.clientTop;\n          ret.left = rect.left - doc.clientLeft;\n        } else {\n          ret.top = rect.top;\n          ret.left = rect.left;\n        }\n\n        return ret;\n      }\n      /** Get the position of the scoll bar of `el`. */\n      // TODO: remove '| Window' as the fallback already happens here\n\n    }, {\n      key: \"getScroll\",\n      value: function getScroll(target) {\n        var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (typeof window === 'undefined') {\n          return 0;\n        }\n\n        var method = top ? 'scrollTop' : 'scrollLeft';\n        var result = 0;\n\n        if (this.isWindow(target)) {\n          result = target[top ? 'pageYOffset' : 'pageXOffset'];\n        } else if (target instanceof Document) {\n          result = target.documentElement[method];\n        } else if (target) {\n          result = target[method];\n        }\n\n        if (target && !this.isWindow(target) && typeof result !== 'number') {\n          result = (target.ownerDocument || target).documentElement[method];\n        }\n\n        return result;\n      }\n    }, {\n      key: \"isWindow\",\n      value: function isWindow(obj) {\n        return obj !== null && obj !== undefined && obj === obj.window;\n      }\n      /**\n       * Scroll `el` to some position with animation.\n       *\n       * @param containerEl container, `window` by default\n       * @param y Scroll to `top`, 0 by default\n       */\n\n    }, {\n      key: \"scrollTo\",\n      value: function scrollTo(containerEl) {\n        var _this6 = this;\n\n        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var target = containerEl ? containerEl : window;\n        var scrollTop = this.getScroll(target);\n        var startTime = Date.now();\n        var easing = options.easing,\n            callback = options.callback,\n            _options$duration = options.duration,\n            duration = _options$duration === void 0 ? 450 : _options$duration;\n\n        var frameFunc = function frameFunc() {\n          var timestamp = Date.now();\n          var time = timestamp - startTime;\n          var nextScrollTop = (easing || easeInOutCubic)(time > duration ? duration : time, scrollTop, y, duration);\n\n          if (_this6.isWindow(target)) {\n            target.scrollTo(window.pageXOffset, nextScrollTop);\n          } else if (target instanceof HTMLDocument || target.constructor.name === 'HTMLDocument') {\n            target.documentElement.scrollTop = nextScrollTop;\n          } else {\n            target.scrollTop = nextScrollTop;\n          }\n\n          if (time < duration) {\n            reqAnimFrame(frameFunc);\n          } else if (typeof callback === 'function') {\n            callback();\n          }\n        };\n\n        reqAnimFrame(frameFunc);\n      }\n    }]);\n\n    return NzScrollService;\n  }();\n\n  NzScrollService.ɵfac = function NzScrollService_Factory(t) {\n    return new (t || NzScrollService)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  NzScrollService.ɵprov = ɵɵdefineInjectable({\n    factory: function NzScrollService_Factory() {\n      return new NzScrollService(ɵɵinject(DOCUMENT));\n    },\n    token: NzScrollService,\n    providedIn: \"root\"\n  });\n  return NzScrollService;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzBreakpointEnum = /*@__PURE__*/function (NzBreakpointEnum) {\n  NzBreakpointEnum[\"xxl\"] = \"xxl\";\n  NzBreakpointEnum[\"xl\"] = \"xl\";\n  NzBreakpointEnum[\"lg\"] = \"lg\";\n  NzBreakpointEnum[\"md\"] = \"md\";\n  NzBreakpointEnum[\"sm\"] = \"sm\";\n  NzBreakpointEnum[\"xs\"] = \"xs\";\n  return NzBreakpointEnum;\n}({});\n\nvar gridResponsiveMap = {\n  xs: '(max-width: 575px)',\n  sm: '(min-width: 576px)',\n  md: '(min-width: 768px)',\n  lg: '(min-width: 992px)',\n  xl: '(min-width: 1200px)',\n  xxl: '(min-width: 1600px)'\n};\nvar siderResponsiveMap = {\n  xs: '(max-width: 479.98px)',\n  sm: '(max-width: 575.98px)',\n  md: '(max-width: 767.98px)',\n  lg: '(max-width: 991.98px)',\n  xl: '(max-width: 1199.98px)',\n  xxl: '(max-width: 1599.98px)'\n};\n\nvar NzBreakpointService = /*@__PURE__*/function () {\n  var NzBreakpointService = /*#__PURE__*/function () {\n    function NzBreakpointService(resizeService, mediaMatcher) {\n      _classCallCheck(this, NzBreakpointService);\n\n      this.resizeService = resizeService;\n      this.mediaMatcher = mediaMatcher;\n      this.resizeService.subscribe().subscribe(function () {});\n    }\n\n    _createClass(NzBreakpointService, [{\n      key: \"subscribe\",\n      value: function subscribe(breakpointMap, fullMap) {\n        var _this7 = this;\n\n        if (fullMap) {\n          var get = function get() {\n            return _this7.matchMedia(breakpointMap, true);\n          };\n\n          return this.resizeService.subscribe().pipe(map(get), startWith(get()), distinctUntilChanged(function (x, y) {\n            return x[0] === y[0];\n          }), map(function (x) {\n            return x[1];\n          }));\n        } else {\n          var _get = function _get() {\n            return _this7.matchMedia(breakpointMap);\n          };\n\n          return this.resizeService.subscribe().pipe(map(_get), startWith(_get()), distinctUntilChanged());\n        }\n      }\n    }, {\n      key: \"matchMedia\",\n      value: function matchMedia(breakpointMap, fullMap) {\n        var _this8 = this;\n\n        var bp = NzBreakpointEnum.md;\n        var breakpointBooleanMap = {};\n        Object.keys(breakpointMap).map(function (breakpoint) {\n          var castBP = breakpoint;\n\n          var matched = _this8.mediaMatcher.matchMedia(gridResponsiveMap[castBP]).matches;\n\n          breakpointBooleanMap[breakpoint] = matched;\n\n          if (matched) {\n            bp = castBP;\n          }\n        });\n\n        if (fullMap) {\n          return [bp, breakpointBooleanMap];\n        } else {\n          return bp;\n        }\n      }\n    }]);\n\n    return NzBreakpointService;\n  }();\n\n  NzBreakpointService.ɵfac = function NzBreakpointService_Factory(t) {\n    return new (t || NzBreakpointService)(ɵngcc0.ɵɵinject(NzResizeService), ɵngcc0.ɵɵinject(ɵngcc1.MediaMatcher));\n  };\n\n  NzBreakpointService.ɵprov = ɵɵdefineInjectable({\n    factory: function NzBreakpointService_Factory() {\n      return new NzBreakpointService(ɵɵinject(NzResizeService), ɵɵinject(MediaMatcher));\n    },\n    token: NzBreakpointService,\n    providedIn: \"root\"\n  });\n  return NzBreakpointService;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzBreakpointEnum, NzBreakpointService, NzDragService, NzResizeService, NzScrollService, NzSingletonService, gridResponsiveMap, siderResponsiveMap, ɵ0 }; //# sourceMappingURL=ng-zorro-antd-core-services.js.map","map":null,"metadata":{},"sourceType":"module"}