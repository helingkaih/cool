{"ast":null,"code":"import { TemplateRef } from '@angular/core';\nimport { coerceBooleanProperty, _isNumberValue, coerceCssPixelValue } from '@angular/cdk/coercion';\nimport { warn } from 'ng-zorro-antd/core/logger';\nimport { Subject, isObservable, from, of } from 'rxjs';\nimport { take } from 'rxjs/operators';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nfunction toArray(value) {\n  var ret;\n\n  if (value == null) {\n    ret = [];\n  } else if (!Array.isArray(value)) {\n    ret = [value];\n  } else {\n    ret = value;\n  }\n\n  return ret;\n}\n\nfunction arraysEqual(array1, array2) {\n  if (!array1 || !array2 || array1.length !== array2.length) {\n    return false;\n  }\n\n  var len = array1.length;\n\n  for (var i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shallowCopyArray(source) {\n  return source.slice();\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isNotNil(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\n\nfunction isNil(value) {\n  return typeof value === 'undefined' || value === null;\n}\n/**\n * Examine if two objects are shallowly equaled.\n */\n\n\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB); // tslint:disable-next-line:prefer-for-of\n\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n\n    if (objA[key] !== objB[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isNonEmptyString(value) {\n  return typeof value === 'string' && value !== '';\n}\n\nfunction isTemplateRef(value) {\n  return value instanceof TemplateRef;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction toBoolean(value) {\n  return coerceBooleanProperty(value);\n}\n\nfunction toNumber(value) {\n  var fallbackValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n\nfunction toCssPixel(value) {\n  return coerceCssPixelValue(value);\n} // tslint:disable no-invalid-this\n\n/**\n * Get the function-property type's value\n */\n\n\nfunction valueFunctionProp(prop) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return typeof prop === 'function' ? prop.apply(void 0, args) : prop;\n}\n\nfunction propDecoratorFactory(name, fallback) {\n  function propDecorator(target, propName, originalDescriptor) {\n    var privatePropName = \"$$__\".concat(propName);\n\n    if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {\n      warn(\"The prop \\\"\".concat(privatePropName, \"\\\" is already exist, it will be overrided by \").concat(name, \" decorator.\"));\n    }\n\n    Object.defineProperty(target, privatePropName, {\n      configurable: true,\n      writable: true\n    });\n    return {\n      get: function get() {\n        return originalDescriptor && originalDescriptor.get ? originalDescriptor.get.bind(this)() : this[privatePropName];\n      },\n      set: function set(value) {\n        if (originalDescriptor && originalDescriptor.set) {\n          originalDescriptor.set.bind(this)(fallback(value));\n        }\n\n        this[privatePropName] = fallback(value);\n      }\n    };\n  }\n\n  return propDecorator;\n}\n/**\n * Input decorator that handle a prop to do get/set automatically with toBoolean\n *\n * Why not using @InputBoolean alone without @Input? AOT needs @Input to be visible\n *\n * @howToUse\n * ```\n * @Input() @InputBoolean() visible: boolean = false;\n *\n * // Act as below:\n * // @Input()\n * // get visible() { return this.__visible; }\n * // set visible(value) { this.__visible = value; }\n * // __visible = false;\n * ```\n */\n\n\nfunction InputBoolean() {\n  return propDecoratorFactory('InputBoolean', toBoolean);\n}\n\nfunction InputCssPixel() {\n  return propDecoratorFactory('InputCssPixel', toCssPixel);\n}\n\nfunction InputNumber(fallbackValue) {\n  return propDecoratorFactory('InputNumber', function (value) {\n    return toNumber(value, fallbackValue);\n  });\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Silent an event by stopping and preventing it.\n */\n\n\nfunction silentEvent(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n\nfunction getElementOffset(elem) {\n  if (!elem.getClientRects().length) {\n    return {\n      top: 0,\n      left: 0\n    };\n  }\n\n  var rect = elem.getBoundingClientRect();\n  var win = elem.ownerDocument.defaultView;\n  return {\n    top: rect.top + win.pageYOffset,\n    left: rect.left + win.pageXOffset\n  };\n}\n/**\n * Investigate if an event is a `TouchEvent`.\n */\n\n\nfunction isTouchEvent(event) {\n  return event.type.startsWith('touch');\n}\n\nfunction getEventPosition(event) {\n  return isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction getRegExp(prefix) {\n  var prefixArray = Array.isArray(prefix) ? prefix : [prefix];\n  var prefixToken = prefixArray.join('').replace(/(\\$|\\^)/g, '\\\\$1');\n\n  if (prefixArray.length > 1) {\n    prefixToken = \"[\".concat(prefixToken, \"]\");\n  }\n\n  return new RegExp(\"(\\\\s|^)(\".concat(prefixToken, \")[^\\\\s]*\"), 'g');\n}\n\nfunction getMentions(value) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '@';\n\n  if (typeof value !== 'string') {\n    return [];\n  }\n\n  var regex = getRegExp(prefix);\n  var mentions = value.match(regex);\n  return mentions !== null ? mentions.map(function (e) {\n    return e.trim();\n  }) : [];\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Much like lodash.\n */\n\n\nfunction padStart(toPad, length, element) {\n  if (toPad.length > length) {\n    return toPad;\n  }\n\n  var joined = \"\".concat(getRepeatedElement(length, element)).concat(toPad);\n  return joined.slice(joined.length - length, joined.length);\n}\n\nfunction padEnd(toPad, length, element) {\n  var joined = \"\".concat(toPad).concat(getRepeatedElement(length, element));\n  return joined.slice(0, length);\n}\n\nfunction getRepeatedElement(length, element) {\n  return Array(length).fill(element).join('');\n}\n\nfunction isPromise(obj) {\n  return !!obj && typeof obj.then === 'function' && typeof obj.catch === 'function';\n}\n\nfunction getPercent(min, max, value) {\n  return (value - min) / (max - min) * 100;\n}\n\nfunction getPrecision(num) {\n  var numStr = num.toString();\n  var dotIndex = numStr.indexOf('.');\n  return dotIndex >= 0 ? numStr.length - dotIndex - 1 : 0;\n}\n\nfunction ensureNumberInRange(num, min, max) {\n  if (isNaN(num) || num < min) {\n    return min;\n  } else if (num > max) {\n    return max;\n  } else {\n    return num;\n  }\n}\n\nfunction isNumberFinite(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\nfunction toDecimal(value, decimal) {\n  return Math.round(value * Math.pow(10, decimal)) / Math.pow(10, decimal);\n}\n\nfunction sum(input) {\n  var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return input.reduce(function (previous, current) {\n    return previous + current;\n  }, initial);\n}\n\nfunction scrollIntoView(node) {\n  var nodeAsAny = node;\n\n  if (nodeAsAny.scrollIntoViewIfNeeded) {\n    /* tslint:disable-next-line:no-string-literal */\n    nodeAsAny.scrollIntoViewIfNeeded(false);\n    return;\n  }\n\n  if (node.scrollIntoView) {\n    node.scrollIntoView(false);\n    return;\n  }\n} // from https://github.com/component/textarea-caret-position\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\n\n\nvar properties = ['direction', 'boxSizing', 'width', 'height', 'overflowX', 'overflowY', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderStyle', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'fontSizeAdjust', 'lineHeight', 'fontFamily', 'textAlign', 'textTransform', 'textIndent', 'textDecoration', 'letterSpacing', 'wordSpacing', 'tabSize', 'MozTabSize'];\nvar isBrowser = typeof window !== 'undefined';\nvar isFirefox = isBrowser && window.mozInnerScreenX != null;\n\nvar _parseInt = function _parseInt(str) {\n  return parseInt(str, 10);\n};\n\nvar ɵ0 = _parseInt;\n\nfunction getCaretCoordinates(element, position, options) {\n  if (!isBrowser) {\n    throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\n  }\n\n  var debug = options && options.debug || false;\n\n  if (debug) {\n    var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  } // The mirror div will replicate the textarea's style\n\n\n  var div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n  var style = div.style;\n  var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle; // currentStyle for IE < 9\n\n  var isInput = element.nodeName === 'INPUT'; // Default textarea styles\n\n  style.whiteSpace = 'pre-wrap';\n\n  if (!isInput) {\n    style.wordWrap = 'break-word'; // only for textarea-s\n  } // Position off-screen\n\n\n  style.position = 'absolute'; // required to return coordinates properly\n\n  if (!debug) {\n    style.visibility = 'hidden';\n  } // not 'display: none' because we want rendering\n  // Transfer the element's properties to the div\n\n\n  properties.forEach(function (prop) {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      style.lineHeight = computed.height;\n    } else {\n      // @ts-ignore\n      style[prop] = computed[prop];\n    }\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > _parseInt(computed.height)) {\n      style.overflowY = 'scroll';\n    }\n  } else {\n    style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position); // The second special handling for input type=\"text\" vs textarea:\n  // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n\n  if (isInput) {\n    div.textContent = div.textContent.replace(/\\s/g, \"\\xA0\");\n  }\n\n  var span = document.createElement('span'); // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // For inputs, just '.' would be enough, but no need to bother.\n\n  span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all\n\n  div.appendChild(span);\n  var coordinates = {\n    top: span.offsetTop + _parseInt(computed.borderTopWidth),\n    left: span.offsetLeft + _parseInt(computed.borderLeftWidth),\n    height: _parseInt(computed.lineHeight)\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#eee';\n    createDebugEle(element, coordinates);\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nfunction createDebugEle(element, coordinates) {\n  var fontSize = getComputedStyle(element).getPropertyValue('font-size');\n  var rect = document.querySelector('#DEBUG') || document.createElement('div');\n  document.body.appendChild(rect);\n  rect.id = 'DEBUG';\n  rect.style.position = 'absolute';\n  rect.style.backgroundColor = 'red';\n  rect.style.height = fontSize;\n  rect.style.width = '1px';\n  rect.style.top = \"\".concat(element.getBoundingClientRect().top - element.scrollTop + window.pageYOffset + coordinates.top, \"px\");\n  rect.style.left = \"\".concat(element.getBoundingClientRect().left - element.scrollLeft + window.pageXOffset + coordinates.left, \"px\");\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isStyleSupport(styleName) {\n  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {\n    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];\n    var documentElement = window.document.documentElement;\n    return styleNameList.some(function (name) {\n      return name in documentElement.style;\n    });\n  }\n\n  return false;\n}\n\nfunction getStyleAsText(styles) {\n  if (!styles) {\n    return '';\n  }\n\n  return Object.keys(styles).map(function (key) {\n    var val = styles[key];\n    return \"\".concat(key, \":\").concat(typeof val === 'string' ? val : val + 'px');\n  }).join(';');\n} // We only handle element & text node.\n\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar ellipsisContainer;\nvar wrapperStyle = {\n  padding: '0',\n  margin: '0',\n  display: 'inline',\n  lineHeight: 'inherit'\n};\n\nfunction pxToNumber(value) {\n  if (!value) {\n    return 0;\n  }\n\n  var match = value.match(/^\\d*(\\.\\d*)?/);\n  return match ? Number(match[0]) : 0;\n}\n\nfunction styleToString(style) {\n  // There are some different behavior between Firefox & Chrome.\n  // We have to handle this ourself.\n  var styleNames = Array.prototype.slice.apply(style);\n  return styleNames.map(function (name) {\n    return \"\".concat(name, \": \").concat(style.getPropertyValue(name), \";\");\n  }).join('');\n}\n\nfunction mergeChildren(children) {\n  var childList = [];\n  children.forEach(function (child) {\n    var prevChild = childList[childList.length - 1];\n\n    if (prevChild && child.nodeType === TEXT_NODE && prevChild.nodeType === TEXT_NODE) {\n      prevChild.data += child.data;\n    } else {\n      childList.push(child);\n    }\n  });\n  return childList;\n}\n\nfunction measure(originEle, rows, contentNodes, fixedContent, ellipsisStr) {\n  var suffixStr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';\n\n  if (!ellipsisContainer) {\n    ellipsisContainer = document.createElement('div');\n    ellipsisContainer.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(ellipsisContainer);\n  } // Get origin style\n\n\n  var originStyle = window.getComputedStyle(originEle);\n  var originCSS = styleToString(originStyle);\n  var lineHeight = pxToNumber(originStyle.lineHeight);\n  var maxHeight = Math.round(lineHeight * (rows + 1) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom)); // Set shadow\n\n  ellipsisContainer.setAttribute('style', originCSS);\n  ellipsisContainer.style.position = 'fixed';\n  ellipsisContainer.style.left = '0';\n  ellipsisContainer.style.height = 'auto';\n  ellipsisContainer.style.minHeight = 'auto';\n  ellipsisContainer.style.maxHeight = 'auto';\n  ellipsisContainer.style.top = '-999999px';\n  ellipsisContainer.style.zIndex = '-1000'; // clean up css overflow\n\n  ellipsisContainer.style.textOverflow = 'clip';\n  ellipsisContainer.style.whiteSpace = 'normal';\n  ellipsisContainer.style.webkitLineClamp = 'none';\n  var contentList = mergeChildren(contentNodes);\n  var container = document.createElement('div');\n  var contentContainer = document.createElement('span');\n  var suffixContainer = document.createTextNode(suffixStr);\n  var fixedContainer = document.createElement('span'); // Add styles in container\n\n  Object.assign(container.style, wrapperStyle);\n  Object.assign(contentContainer.style, wrapperStyle);\n  Object.assign(fixedContainer.style, wrapperStyle);\n  contentList.forEach(function (n) {\n    contentContainer.appendChild(n);\n  });\n  contentContainer.appendChild(suffixContainer);\n  fixedContent.forEach(function (node) {\n    fixedContainer.appendChild(node.cloneNode(true));\n  });\n  container.appendChild(contentContainer);\n  container.appendChild(fixedContainer); // Render in the fake container\n\n  ellipsisContainer.appendChild(container); // Check if ellipsis in measure div is height enough for content\n\n  function inRange() {\n    return ellipsisContainer.offsetHeight < maxHeight;\n  }\n\n  if (inRange()) {\n    var text = ellipsisContainer.innerHTML;\n    ellipsisContainer.removeChild(container);\n    return {\n      contentNodes: contentNodes,\n      text: text,\n      ellipsis: false\n    };\n  } // We should clone the childNode since they're controlled by React and we can't reuse it without warning\n\n\n  var childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter(function (_ref) {\n    var nodeType = _ref.nodeType;\n    return nodeType !== COMMENT_NODE;\n  });\n  var fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n  ellipsisContainer.removeChild(container); // ========================= Find match ellipsis content =========================\n\n  ellipsisContainer.innerHTML = ''; // Create origin content holder\n\n  var ellipsisContentHolder = document.createElement('span');\n  ellipsisContainer.appendChild(ellipsisContentHolder);\n  var ellipsisTextNode = document.createTextNode(ellipsisStr + suffixStr);\n  ellipsisContentHolder.appendChild(ellipsisTextNode);\n  fixedNodes.forEach(function (childNode) {\n    ellipsisContainer.appendChild(childNode);\n  }); // Append before fixed nodes\n\n  function appendChildNode(node) {\n    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n  } // Get maximum text\n\n\n  function measureText(textNode, fullText) {\n    var startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;\n    var lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var midLoc = Math.floor((startLoc + endLoc) / 2);\n    textNode.textContent = fullText.slice(0, midLoc);\n\n    if (startLoc >= endLoc - 1) {\n      // Loop when step is small\n      for (var step = endLoc; step >= startLoc; step -= 1) {\n        var currentStepText = fullText.slice(0, step);\n        textNode.textContent = currentStepText;\n\n        if (inRange() || !currentStepText) {\n          return step === fullText.length ? {\n            finished: false,\n            node: document.createTextNode(fullText)\n          } : {\n            finished: true,\n            node: document.createTextNode(currentStepText)\n          };\n        }\n      }\n    }\n\n    if (inRange()) {\n      return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n    } else {\n      return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n    }\n  }\n\n  function measureNode(childNode, index) {\n    var type = childNode.nodeType;\n\n    if (type === ELEMENT_NODE) {\n      // We don't split element, it will keep if whole element can be displayed.\n      // appendChildNode(childNode);\n      if (inRange()) {\n        return {\n          finished: false,\n          node: contentList[index]\n        };\n      } // Clean up if can not pull in\n\n\n      ellipsisContentHolder.removeChild(childNode);\n      return {\n        finished: true,\n        node: null\n      };\n    } else if (type === TEXT_NODE) {\n      var fullText = childNode.textContent || '';\n      var textNode = document.createTextNode(fullText);\n      appendChildNode(textNode);\n      return measureText(textNode, fullText);\n    } // Not handle other type of content\n    // PS: This code should not be attached after react 16\n\n\n    return {\n      finished: false,\n      node: null\n    };\n  }\n\n  var ellipsisNodes = [];\n  childNodes.some(function (childNode, index) {\n    var _measureNode = measureNode(childNode, index),\n        finished = _measureNode.finished,\n        node = _measureNode.node;\n\n    if (node) {\n      ellipsisNodes.push(node);\n    }\n\n    return finished;\n  });\n  var result = {\n    contentNodes: ellipsisNodes,\n    text: ellipsisContainer.innerHTML,\n    ellipsis: true\n  };\n\n  while (ellipsisContainer.firstChild) {\n    ellipsisContainer.removeChild(ellipsisContainer.firstChild);\n  }\n\n  return result;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar scrollbarVerticalSize;\nvar scrollbarHorizontalSize; // Measure scrollbar width for padding body during modal show/hide\n\nvar scrollbarMeasure = {\n  position: 'absolute',\n  top: '-9999px',\n  width: '50px',\n  height: '50px'\n};\n\nfunction measureScrollbar() {\n  var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vertical';\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ant';\n\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    return 0;\n  }\n\n  var isVertical = direction === 'vertical';\n\n  if (isVertical && scrollbarVerticalSize) {\n    return scrollbarVerticalSize;\n  } else if (!isVertical && scrollbarHorizontalSize) {\n    return scrollbarHorizontalSize;\n  }\n\n  var scrollDiv = document.createElement('div');\n  Object.keys(scrollbarMeasure).forEach(function (scrollProp) {\n    // @ts-ignore\n    scrollDiv.style[scrollProp] = scrollbarMeasure[scrollProp];\n  }); // apply hide scrollbar className ahead\n\n  scrollDiv.className = \"\".concat(prefix, \"-hide-scrollbar scroll-div-append-to-body\"); // Append related overflow style\n\n  if (isVertical) {\n    scrollDiv.style.overflowY = 'scroll';\n  } else {\n    scrollDiv.style.overflowX = 'scroll';\n  }\n\n  document.body.appendChild(scrollDiv);\n  var size = 0;\n\n  if (isVertical) {\n    size = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    scrollbarVerticalSize = size;\n  } else {\n    size = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n    scrollbarHorizontalSize = size;\n  }\n\n  document.body.removeChild(scrollDiv);\n  return size;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction ensureInBounds(value, boundValue) {\n  return value ? value < boundValue ? value : boundValue : boundValue;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction inNextTick() {\n  var timer = new Subject();\n  Promise.resolve().then(function () {\n    return timer.next();\n  });\n  return timer.pipe(take(1));\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction wrapIntoObservable(value) {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { InputBoolean, InputCssPixel, InputNumber, arraysEqual, createDebugEle, ensureInBounds, ensureNumberInRange, getCaretCoordinates, getElementOffset, getEventPosition, getMentions, getPercent, getPrecision, getRegExp, getRepeatedElement, getStyleAsText, inNextTick, isNil, isNonEmptyString, isNotNil, isNumberFinite, isPromise, isStyleSupport, isTemplateRef, isTouchEvent, measure, measureScrollbar, padEnd, padStart, properties, pxToNumber, scrollIntoView, shallowCopyArray, shallowEqual, silentEvent, sum, toArray, toBoolean, toCssPixel, toDecimal, toNumber, valueFunctionProp, wrapIntoObservable, ɵ0 }; //# sourceMappingURL=ng-zorro-antd-core-util.js.map","map":null,"metadata":{},"sourceType":"module"}